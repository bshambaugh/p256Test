import { createJWS, ES256Signer } from 'did-jwt';
import { RPCError, createHandler } from 'rpc-utils';
import stringify from 'fast-json-stable-stringify';
import * as u8a from 'uint8arrays';
import pkg from 'elliptic';
const { ec: EC } = pkg;
import { compressedKeyInHexfromRaw, encodeDIDfromHexString, rawKeyInHexfromUncompressed } from 'did-key-creator';
const ec = new EC('p256');
function toStableObject(obj) {
    return JSON.parse(stringify(obj));
}
function toGeneralJWS(jws) {
    const [protectedHeader, payload, signature] = jws.split('.');
    return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
    };
}
const sign = async (payload, did, secretKey, protectedHeader = {}) => {
    const kid = `${did}#${did.split(':')[2]}`;
    const signer = ES256Signer(secretKey);
    const header = toStableObject(Object.assign(protectedHeader, { kid, alg: 'ES256' }));
    return createJWS(typeof payload === 'string' ? payload : toStableObject(payload), signer, header);
};
const didMethods = {
    did_authenticate: async ({ did, privateKey }, params) => {
        const response = await sign({
            did,
            aud: params.aud,
            nonce: params.nonce,
            paths: params.paths,
            exp: Math.floor(Date.now() / 1000) + 600,
        }, did, privateKey);
        return toGeneralJWS(response);
    },
    did_createJWS: async ({ did, privateKey }, params) => {
        const requestDid = params.did.split('#')[0];
        if (requestDid !== did)
            throw new RPCError(4100, `Unknown DID: ${did}`);
        const jws = await sign(params.payload, did, privateKey, params.protected);
        return { jws: toGeneralJWS(jws) };
    },
    did_decryptJWE: async () => {
        throw new RPCError(4100, 'Decryption not supported');
    },
};
export class P256Provider {
    constructor(secretKey) {
        const kp = ec.keyFromPrivate(secretKey);
        const publicKey = String(kp.getPublic('hex'));
        const compressedPublicKey = compressedKeyInHexfromRaw(rawKeyInHexfromUncompressed(publicKey));
        const privateKey = u8a.fromString(String(kp.getPrivate('hex')), 'hex');
        const did = encodeDIDfromHexString('p256-pub', compressedPublicKey);
        const handler = createHandler(didMethods);
        this._handle = async (msg) => await handler({ did, privateKey }, msg);
    }
    get isDidProvider() {
        return true;
    }
    async send(msg) {
        return await this._handle(msg);
    }
}
//# sourceMappingURL=index.js.map